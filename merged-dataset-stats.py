#!/usr/bin/env python3

import argparse
import os
from multiprocessing import Pool
import numpy as np
import sys

# python wf-attack-vpn/merged-dataset-stats.py -d captures

ap = argparse.ArgumentParser()
ap.add_argument("-d", required=True, default="", help="root folder of client/server dataset")
ap.add_argument("-w", required=False, type=int, default=10,
    help="number of workers for loading traces from disk")
ap.add_argument("--min", required=False, type=int, default=0, help="smallest packet size to consider")
args = vars(ap.parse_args())


def main():
    '''
    Analyse all capture files in a directory, generated by rds-collect
    '''

    print(f"walking {args['d']}, this might take a long time...")

    # walk the dataset folder
    todo = []
    for root, dirs, files in os.walk(args["d"], topdown = False):
        for name in files:
            if ".log" in name:
                todo.append(
                    (os.path.join(root, name), name)
                )

    p = Pool(args["w"])
    results = p.starmap(parse_trace, todo)

    # store statistics gathered from the file
    sent_lines, recv_lines = [], []
    sent_bytes, recv_bytes = [], []
    multiple_clients       = []
    one_client             = []
    for result in results:
        # only analyse files that have one client
        if result[4] == 1:
            sent_lines.append(result[0])
            recv_lines.append(result[1])
            sent_bytes.append(result[2])
            recv_bytes.append(result[3])
            one_client.append(result[5])
        else:
            multiple_clients.append(result[5])

    # convert to numpy arrays
    sent_lines = np.array(sent_lines)
    recv_lines = np.array(recv_lines)
    sent_bytes = np.array(sent_bytes)
    recv_bytes = np.array(recv_bytes)

    try:
        # print some descriptive statistics
        print(f"sent lines: {np.mean(sent_lines):.2f} +- {np.std(sent_lines):.2f}, median: {np.median(sent_lines):.2f},  min: {np.min(sent_lines)}, max: {np.max(sent_lines)}")
        print(f"recv lines: {np.mean(recv_lines):.2f} +- {np.std(recv_lines):.2f}, median: {np.median(recv_lines):.2f},  min: {np.min(recv_lines)}, max: {np.max(recv_lines)}")
        print("---------------------------------------------------------------------------------------------------------------------------------------------------------------")
        print(f"sent bytes: {np.mean(sent_bytes):.2f} +- {np.std(sent_bytes):.2f}, min: {np.min(sent_bytes)}, max: {np.max(sent_bytes)}")
        print(f"recv bytes: {np.mean(recv_bytes):.2f} +- {np.std(recv_bytes):.2f}, min: {np.min(recv_bytes)}, max: {np.max(recv_bytes)}")
        print("---------------------------------------------------------------------------------------------------------------------------------------------------------------")
    except:
        print("ERROR while calculating stastics")
    print(f" {len(one_client)} files are with 1 client")
    print(f" {len(multiple_clients)} files are with to many clients")
    #print(multiple_clients)


def parse_trace(fname, name):
    '''
    Get statistics from a capture file, generated by rds-collect
    Input:
        fname: path and name to the file which should be analyzed
        name: 
    Output:
        Tuple with statistics of the file
        sent_lines, recv_lines:  the number of packets that was sent/received
        sent_bytes, recv_bytes:  the sent/received packets total size in bytes
        clients:                 Clients used in the stream
        fname:                   the file that was analyzed
    '''

    # gathered statistics
    sent_lines, recv_lines = 0, 0
    sent_bytes, recv_bytes = 0, 0
    clients = 0

    # temporary placeholder name
    ipHost = '10'
    
    with open(fname, "r") as f:
        for line in f:
            parts = line.strip().split(",")

            # unusable lines that would not be used either way
            if len(parts) < 3:
                continue

            # (<sender IP>, <reciever IP>)
            direction = parts[1]
            # size in bytes
            size      = int(parts[2])

            if size < args["min"]:
                continue

            sender_receiver = str(direction).split(",")
            print(sender_receiver)
            # if no or only one IP address, skip this packet
            if len(sender_receiver) < 2:
                continue
            else:
                sender          = sender_receiver[0]
                receiver        = sender_receiver[1]

                # get direction
                if sender == "":
                    continue
                elif sender == ipHost:
                    sent_bytes += size
                    sent_lines += 1
                elif receiver == ipHost:
                    recv_bytes += size
                    recv_lines += 1
                else:
                    sender_start_ip = sender.split('.')
                    clients += 1
                    if sender_start_ip[0] == '10':
                        ipHost = sender_start_ip[0]
                        sent_bytes += size
                        sent_lines += 1
                    else:
                        ipHost = sender_start_ip[1]
                        recv_bytes += size
                        recv_lines += 1

    return (sent_lines, recv_lines, sent_bytes, recv_bytes, clients, fname)

if __name__ == "__main__":
    main()
